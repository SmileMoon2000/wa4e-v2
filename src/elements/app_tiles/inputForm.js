import { html } from 'lit';
import { TileBase } from './tileBase';
import '../mySubComponents.js';

class inputTile extends TileBase {
  render() {
    this.formFields = this.appConf.fields;
    this.subComponents = this.appConf.subComponents;
    this.input_fields = this.makeNestedCallbackFields();

    return [
      super.render(),
      html`
        <!-- This 'div' defines the tile as a grid item and the style options
      defines the corners of the tile on the grid. -->
        <div>
          <h2>${this.appConf.title}</h2>
          <!-- input form autogenerated fields -->
          <div>${this.input_fields}</div>
          <div class="d-grid gap-2 d-md-flex justify-content-md-around p-2">
            <!-- buttons -->
            <button
              class="btn btn-primary col-sm-12 col-md-6"
              @click=${() => this.appUpdate()}
            >
              SUBMIT
            </button>
            <button
              class="btn btn-outline-secondary col"
              @click=${() => this.tileReload()}
            >
              RESET
            </button>
            <button
              class="btn btn-outline-info col"
              @click=${() => this.showHelp()}
            >
              HELP
            </button>
          </div>
        </div>
      `,
    ];
  }

  makeNestedCallbackFields() {
    return html`${Object.keys(this.formFields).map((keyOuter, index) => {
      const subComponent = this.subComponents.find(
        element => element.index === index
      );
      let htmlReturn = html``;
      if (typeof subComponent === 'undefined') {
        htmlReturn = html` <h3>${keyOuter}</h3>
          ${Object.keys(this.appConf.fields[`${keyOuter}`]).map(
            key =>
              html` <div class="input-group">
                <span
                  class="input-group-text col-auto text-wrap text-break"
                  for="${key}"
                  style="width: 25%; text-align: right;"
                  >${html([this.appConf.fields[keyOuter][key][2]])}</span
                >
                <input
                  class="form-control"
                  id="${key}"
                  .value="${this.appConf.fields[keyOuter][key][0]}"
                  @change=${e => {
                    this.appConf.fields[keyOuter][key][0] = Number(
                      e.target.value
                    );
                  }}
                />
                <span
                  class="input-group-text col-auto text-wrap text-break"
                  for="${key}"
                  style="width: 20%; text-align: left;"
                  >${html([this.appConf.fields[keyOuter][key][1]])}</span
                >
              </div>`
          )}`;
      } else {
        htmlReturn = html`
          ${subComponent.position === 'beforeTitle'
            ? html`${this.makeSubComponent(index)}
                <h3>${keyOuter}</h3>`
            : html`<h3>${keyOuter}</h3>`}${subComponent.position ===
          'afterTitle'
            ? html`${this.makeSubComponent(index)}`
            : html` ${Object.keys(this.appConf.fields[`${keyOuter}`]).map(
                key =>
                  html`<div class="input-group">
                    <span
                      class="input-group-text col-auto text-wrap text-break"
                      for="${key}"
                      style="width: 25%; text-align: right;"
                      >${html([this.appConf.fields[keyOuter][key][2]])}</span
                    >
                    <input
                      class="form-control"
                      id="${key}"
                      .value="${this.appConf.fields[keyOuter][key][0]}"
                      @change=${e => {
                        this.appConf.fields[keyOuter][key][0] = Number(
                          e.target.value
                        );
                      }}
                    />
                    <span
                      class="input-group-text col-auto text-wrap text-break"
                      for="${key}"
                      style="width: 20%; text-align: left;"
                      >${html([this.appConf.fields[keyOuter][key][1]])}</span
                    >
                  </div>`
              )}`}${subComponent.position === 'end'
            ? html`${this.makeSubComponent(index)}`
            : html` ${Object.keys(this.appConf.fields[`${keyOuter}`]).map(
                key =>
                  html`<div class="input-group">
                    <span
                      class="input-group-text col-auto text-wrap text-break"
                      for="${key}"
                      style="width: 25%; text-align: right;"
                      >${html([this.appConf.fields[keyOuter][key][2]])}</span
                    >
                    <input
                      class="form-control"
                      id="${key}"
                      .value="${this.appConf.fields[keyOuter][key][0]}"
                      @change=${e => {
                        this.appConf.fields[keyOuter][key][0] = Number(
                          e.target.value
                        );
                      }}
                    />
                    <span
                      class="input-group-text col-auto text-wrap text-break"
                      for="${key}"
                      style="width: 20%; text-align: left;"
                      >${html([this.appConf.fields[keyOuter][key][1]])}</span
                    >
                  </div>`
              )}`}
        `;
      }
      return htmlReturn;
    })}`;
  }

  makeSubComponent(index) {
    // Currently this only supportsd radio tiles but other subcomponent tile
    // classes can be added using the same structure as found in appGeneric
    const component = this.subComponents.find(
      element => element.index === index
    );
    const subcomponentHTML = html` ${component.type === 'radio-tile'
      ? html`<div class="card mx-auto p-1">
          <radio-tile .appConf=${component}></radio-tile>
        </div>`
      : html`<p>Component ${component.type} Not Recognised</p>`}`;
    return html`${subcomponentHTML}`;
  }

  appUpdate() {
    const myEvent = new CustomEvent('updated', {
      bubbles: true,
      composed: true,
    });
    this.dispatchEvent(myEvent);
  }

  tileReload() {
    const myEvent = new CustomEvent('reset', {
      bubbles: true,
      composed: true,
    });
    this.dispatchEvent(myEvent);
  }

  showHelp() {
    // eslint-disable-next-line no-alert
    window.alert(this.appConf.helpText);
  }
}
customElements.define('input-tile', inputTile);
